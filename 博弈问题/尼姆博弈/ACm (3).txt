爱丽丝和鲍勃决定玩一个新的石头游戏。在游戏开始的时候，他们选择了一堆石头（1 <= n <= 10）。爱丽丝和鲍尔依次移动石块。 
在游戏的每个步骤中，玩家选择一堆，至少去除一块石头，然后自由地将石头从这个堆移动到仍然有石头的任何其他桩。 
例如：n = 4，并且桩有（3,1,4,2）个石头。如果玩家选择了第一个桩并将其移除，则可以达到以下状态。 
2 1 4 2 
1 2 4 2（移动一块石头到桩2） 
1 1 5 2（移动一块石头到桩3） 
1 1 4 3（移动一块石头到桩4） 
0 2 5 2（移动一块石头到桩2和另一个到桩3） 
0 2 4 3（移动一块石头到桩2，另一个到桩4） 
0 1 5 3（移动一块石头到桩3，另一块到桩4） 
0 3 4 2两块石头堆2） 
0 1 6 2（将两块石头移动到桩3） 
0 1 4 4（将两块石头移动到桩4） 
爱丽丝总是先移动。假设爱丽丝和鲍勃都在游戏中做得最好。 
你要写一个程序，以确定谁将终于赢得比赛。 
输入

该输入包含几个测试用例。每个测试用例的第一行包含整数n，表示堆数。以下n个整数描述了游戏开始时每堆中的宝石数量，您可以假设每个桩中的石块数量不会超过100. 
最后一个测试用例之后为零。 
产量

对于每个测试用例，如果爱丽丝赢得游戏，输出1，否则输出0。 
样品输入

3
2 1 3
2
1 1
0
样品输出

1
0

#include <cstdio>  
#include <iostream>  
#include <algorithm>  
using namespace std;  
int main()  
{  
    int n;  
    int stone[11], num[101];  
    while (scanf("%d", &n), n)  
    {  
        int i;  
        memset(num, 0, sizeof(num));  
        for (i=0; i<n; i++)  
        {  
            scanf("%d", &stone[i]);  
            num[stone[i]] ++;  
        }  
        sort(stone, stone+1);  
          
  
        int number = 0;  
  
        for (i=1; i<=100; i++)  
            if (num[i] % 2 == 1)  
                number ++;  
  
        if (number) puts("1");  
        else puts("0");  
    }  
    return 0;  
}


